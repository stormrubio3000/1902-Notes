# Notes 3-14-19
DOCKERS

## Extras
- azure devops: Organization settings, can check retention and parallel settings
	- check minutes used up and free status etc
- [Install docker toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/)
	- we run our docker in a Linux VM when we start the app
- https://hub.docker.com/_/microsoft-dotnet-core where we can get docker images to pull


## Docker (self notes)
- https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/
- **Containerization** approach in sw dev in which an app or service, its dependencies and configs are packaged together as a container image.
	- can test that containerized app as a unit and delpoy as a container image instance to the OS
	- allows devs and IT to deploy across env with little or no mods
	- containers isolate apps from each other on shared OS
		- run on top of container host that then runs on OS 
		- faller footprints than a VM image
	- scalability: scale out quickly by creating new containers for short term tasks
	- summary: isolation, portability, agility, scalability, and control across app lifecycle workflow
- Open sourced project for automating delpoyment of apps as portabl, self-sufficient containers that run on cloud or on-premises
- comparison between VMs and Docker Containers
	- ![Comparison for VMs and Docker containers](https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/media/image3.png "vms vs docker")
- **container image**: package with dep and info needed to create a container
	- image includes all dep (e.g. frameworks) + deployment and execution fonfigs used by container runtime
	- immutable once created
- **container**: instance of a Docker image
	- image is a static representation of the app or service and its config and dependencies
		- store images in a registry that acts as a library of images
	- represents execution of a single app, procss or service.
	- contains content of docker image, exec env, and set of instructions
	- when scaling project you create multiple instances of a container from same image
- ![Docker app life cycle](https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/docker-application-lifecycle/media/image2.png)

## Virtualization
- single boot: `[[Apps][apps][apps] dep]->[OS]->[hardware]`
	- no virtualization
- dual boot: has two OS to switch between (Ubuntu represents!) 
	- no virtualization
- OS-level virtualization: `[guest os [apps][dep]] [guest os [apps][dep]] -> [Hypervisor[apps][apps]] -> [host OS] -> [Hardware]`
	- top two guest os with apps are virtual machines
	- Hypervisor is generally VirtualBox and VMWare
		- expose VB hardware interface to gues OSes and connect that to real hardware in host OS
		- just a big file that won't use any resources when you turn image off
	- when you start a VM you most allocate fixed blocks of RAM
	- use over containers if you want to do Linux stuffs
- containers: `[container engine [app][dep] + [app][dep]..] -> [OS] -> [Hardware]`
	- dependencies like NuGet and .NET Core runtime packages found in container engine shard to each of those [dep]
		- need just one dep in one place and it applies to all apps (all apps isolated from one another)
	- flexibly use resources like memory in same way as regular processes
	- more granular when creating many instances within container
	- faster to set up compared to VM
	- bit more of a learning curve compared to VMs

## Use Docker
- if we had windows professional or linux, we can install real Docker
	- but non-pro windows 10 doesnt support containers (yet?) so we use *Docker Toolbox*
- Docker toolbox is meant to be one click set up for running Linux containers on Windows using small linux VM
- [Docker Engine [Docker CLI (Client(Docker CLI))]  <--REST API--> [Docker Toolbox (server(server daemon))]]
- can use regular command with `docker-machine start`
	- `docker-machine stop` to stop
- images are built in layers
- Docker Client speaks to a Docker daemon which pulls an image from the Docker Hub
	- then the daemon creates a new container from image which runs executable that produces output
	- Docker daemon streamed that output to Docker client, which can be sent to terminal
- docker commands
	- `docker run <image-name>`
		- this starts a new container from the given image (downloading image if necessary)
	- `docker pull <image-name>`
		- just downloads the image (updates if new version)
- docker image:
	- template for container to start
	- has whole file sys
	- has pointer to some program inside the image that should run when we start container
	- images are **layered** - every image has some base image with new layers added on top
- Dockerfile
	- provides instructions to build a new image from some base image
	- FROM: 
		- Set the baseImage to use for subsequent instructions. FROM must be the first instruction in a Dockerfile
		- sets the base image to use for subsequent layers
	- COPY:
		- Copy files or folders from source to the dest path in the image's filesystem.
	- CMD:
		- what to run when we start the container
	- other commands used
		- `winpty docker pull mcr.microsoft.com/dotnet/core/sdk:2.2`
			- winpty used for windows to displays download nicely
	- `docker-machine ip` : finds our ip
	- `docker rm a96` to remove a container
	- `docker container ls` lists out containers
		- ls -a for everything
	- `docker logs someNumberForProject`
- **Check out nick's notes for the missing parts**
- Orchestration
	- Docker Swarm
	- Kubernetics

## Application Deployment
- on-premises servers/resources
	- company that is using the service pays for it
	- installed and runs on computers on the premises of the person or organization using the software, 
		- rather than at a remote facility such as a server farm or cloud. 
		- On-premises software is sometimes referred to as “shrinkwrap” software, and off-premises software is commonly called “software as a service” ("SaaS") or “cloud computing”.
- cloud resources/services
	- **SaaS**: Software as a Service
		- webapps, Gmail, Office 365, Project1, Github, Azure Pipeline, Amazon CodePipeline, Amazon CodeBuild
		- abstract away everything but the app
			- hardware, disk, network, OS ... abstracted
	- **IaaS**: Infrastructure as a Service
		- Azure VM
		- Amazon EC2 (AWS)
		- Cloud Platforms
			- Amazon Web Services (AWS)
			- Microsoft Azure
			- Google Cloud
	- on premises cloud is called *"hybrid cloud"*
	- *multi cloud* is using cloud from more than one provider
		- in the off chance that one of the provider fails, you have a backup that would work
	- **SLA** service level agreement
		- is what % of the time that the resource is available (e.g. 99.999%) [uptime]
		- promise that it wont be down for more than x # of hours per year [downtime]
			- pay more for more guarantee (yay... what a scam)
	- region
		- east US, Central US, Australia, West Europe etc...
		- can have our resource guaranteed on physical server from an area
		- *have copies of our app in many areas, for **faster access** for customers*
		- redundency is good in case one area is down
		- availabilty zones
			- 1, 2, 3, 4 as our sample data centers in same region but spaced away
			- if one goes down, then unlikely others will go down as well
	- Storage
		- Azure Disks, Files, Blobs, Amazon   S3
		- disk storage: connect to 1 VM at a time
		- File Storage: connect to many things at once
		- Blob Storage: unstructured, no dirs, no FS
			- large/streamed files
			- static asset files like images
	- **PaaS**: Platform as a service 
		- abstract away physical location, electricity, some/most physical stuff
		- abstract away OS, network, disk, hardware
		- Azure App Service
			- take care of installing compilers, and other frameworks, etc.., just need to plug in code
		- Amazon Elastic Beanstalk
	- **CaaS**: Container as a Service
		- don't know what OS we're working with
		- AKS Azur Kubernetes Service
	- **DBaaS**: DB as a Service
		- e.g. Azure SQL
	- public, private, government cloud (can't leave the country)
- CI tools
	- Azure pipelines
	- Jenkins
	- TravisCI
	- CircleCI
	- Appvoyer
	- AWE Code Pipeline/CodeBuild
	- GoCD
		- first to have Continuous Deployment

## Project 2
- would like us to use Github Projects
	- dont need Azure board this time
- Data Model (what data is there and what col are there)
	- at least 2 many to many relationships
	- as complex as project 1
- User interactions
	- they should do lots of things ~~like blow up the world~~ 
	- lot of buttons, inputs, hover effects, whatever looks nice
- requirment for Authentication
	- some idea of users (username, pw)
	- not all users are equal (e.g. admin can view more things than users)
- throw in layered architecture?
- CI, Pipeline, deploy to App Service
- Branching structure
- EXTRAS
	- has to be MVC, EF, but can use any kinds of SQL or external APIs
	- ML.NET has some cool libraries for machine learning (chatbot etc)
- Dockerfile, but don't need to completely implement it

## Project 2 tomorrow goals
- make team of 3
- make user stories
- make paragraph describes what project will be about
- make a basic DB layout (needs multiplicity min 2)
- MVP: minimum viable product 
	- (try not to be too ambitious, need something that works first and could be acceptable if not all features are there)
- Azure keyvault we could look into